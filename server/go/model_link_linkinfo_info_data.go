/*
 * netConfD API
 *
 * Network Configurator service
 *
 * API version: 0.1.0
 * Contact: support@athonet.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
)

// LinkLinkinfoInfoData Additional information on the link
type LinkLinkinfoInfoData struct {
	// Bonding modes. Supported Modes:   * `balance-rr` - Round-robin: Transmit network packets in sequential order from the first available network interface (NIC) slave through the last. This mode provides load balancing and fault tolerance.   * `active-backup` - Active-backup: Only one NIC slave in the bond is active. A different slave becomes active if, and only if, the active slave fails. The single logical bonded interface's MAC address is externally visible on only one NIC (port) to avoid distortion in the network switch. This mode provides fault tolerance.   * `balance-xor` - XOR: Transmit network packets based on a hash of the packet's source and destination. The default algorithm only considers MAC addresses (layer2). Newer versions allow selection of additional policies based on IP addresses (layer2+3) and TCP/UDP port numbers (layer3+4). This selects the same NIC slave for each destination MAC address, IP address, or IP address and port combination, respectively. This mode provides load balancing and fault tolerance.   * `broadcast` - Broadcast: Transmit network packets on all slave network interfaces. This mode provides fault tolerance.   * `802.3ad` - IEEE 802.3ad Dynamic link aggregation: Creates aggregation groups that share the same speed and duplex settings. Utilizes all slave network interfaces in the active aggregator group according to the 802.3ad specification. This mode is similar to the XOR mode above and supports the same balancing policies. The link is set up dynamically between two LACP-supporting peers.   * `balance-tlb` - Adaptive transmit load balancing: Linux bonding driver mode that does not require any special network-switch support. The outgoing network packet traffic is distributed according to the current load (computed relative to the speed) on each network interface slave. Incoming traffic is received by one currently designated slave network interface. If this receiving slave fails, another slave takes over the MAC address of the failed receiving slave.   * `balance-alb` - Adaptive load balancing: includes balance-tlb plus receive load balancing (rlb) for IPV4 traffic, and does not require any special network switch support. The receive load balancing is achieved by ARP negotiation. The bonding driver intercepts the ARP Replies sent by the local system on their way out and overwrites the source hardware address with the unique hardware address of one of the NIC slaves in the single logical bonded interface such that different network-peers use different MAC addresses for their network packet traffic. 
	Mode *string `json:"mode,omitempty"`
	// Specifies the MII link monitoring frequency in milliseconds.  The default value is 0, and this will disable the MII monitor 
	Miimon *int32 `json:"miimon,omitempty"`
	// Specifies the time, in milliseconds, to wait before enabling a slave after a  link recovery has been detected. The updelay value should be a multiple of the miimon value 
	Updelay *int32 `json:"updelay,omitempty"`
	// Specifies the time, in milliseconds, to wait before disabling a slave after a  link failure has been detected. The downdelay value should be a multiple of the miimon value. 
	Downdelay *int32 `json:"downdelay,omitempty"`
}

// NewLinkLinkinfoInfoData instantiates a new LinkLinkinfoInfoData object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewLinkLinkinfoInfoData() *LinkLinkinfoInfoData {
	this := LinkLinkinfoInfoData{}
	return &this
}

// NewLinkLinkinfoInfoDataWithDefaults instantiates a new LinkLinkinfoInfoData object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewLinkLinkinfoInfoDataWithDefaults() *LinkLinkinfoInfoData {
	this := LinkLinkinfoInfoData{}
	return &this
}

// GetMode returns the Mode field value if set, zero value otherwise.
func (o *LinkLinkinfoInfoData) GetMode() string {
	if o == nil || o.Mode == nil {
		var ret string
		return ret
	}
	return *o.Mode
}

// GetModeOk returns a tuple with the Mode field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LinkLinkinfoInfoData) GetModeOk() (*string, bool) {
	if o == nil || o.Mode == nil {
		return nil, false
	}
	return o.Mode, true
}

// HasMode returns a boolean if a field has been set.
func (o *LinkLinkinfoInfoData) HasMode() bool {
	if o != nil && o.Mode != nil {
		return true
	}

	return false
}

// SetMode gets a reference to the given string and assigns it to the Mode field.
func (o *LinkLinkinfoInfoData) SetMode(v string) {
	o.Mode = &v
}

// GetMiimon returns the Miimon field value if set, zero value otherwise.
func (o *LinkLinkinfoInfoData) GetMiimon() int32 {
	if o == nil || o.Miimon == nil {
		var ret int32
		return ret
	}
	return *o.Miimon
}

// GetMiimonOk returns a tuple with the Miimon field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LinkLinkinfoInfoData) GetMiimonOk() (*int32, bool) {
	if o == nil || o.Miimon == nil {
		return nil, false
	}
	return o.Miimon, true
}

// HasMiimon returns a boolean if a field has been set.
func (o *LinkLinkinfoInfoData) HasMiimon() bool {
	if o != nil && o.Miimon != nil {
		return true
	}

	return false
}

// SetMiimon gets a reference to the given int32 and assigns it to the Miimon field.
func (o *LinkLinkinfoInfoData) SetMiimon(v int32) {
	o.Miimon = &v
}

// GetUpdelay returns the Updelay field value if set, zero value otherwise.
func (o *LinkLinkinfoInfoData) GetUpdelay() int32 {
	if o == nil || o.Updelay == nil {
		var ret int32
		return ret
	}
	return *o.Updelay
}

// GetUpdelayOk returns a tuple with the Updelay field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LinkLinkinfoInfoData) GetUpdelayOk() (*int32, bool) {
	if o == nil || o.Updelay == nil {
		return nil, false
	}
	return o.Updelay, true
}

// HasUpdelay returns a boolean if a field has been set.
func (o *LinkLinkinfoInfoData) HasUpdelay() bool {
	if o != nil && o.Updelay != nil {
		return true
	}

	return false
}

// SetUpdelay gets a reference to the given int32 and assigns it to the Updelay field.
func (o *LinkLinkinfoInfoData) SetUpdelay(v int32) {
	o.Updelay = &v
}

// GetDowndelay returns the Downdelay field value if set, zero value otherwise.
func (o *LinkLinkinfoInfoData) GetDowndelay() int32 {
	if o == nil || o.Downdelay == nil {
		var ret int32
		return ret
	}
	return *o.Downdelay
}

// GetDowndelayOk returns a tuple with the Downdelay field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *LinkLinkinfoInfoData) GetDowndelayOk() (*int32, bool) {
	if o == nil || o.Downdelay == nil {
		return nil, false
	}
	return o.Downdelay, true
}

// HasDowndelay returns a boolean if a field has been set.
func (o *LinkLinkinfoInfoData) HasDowndelay() bool {
	if o != nil && o.Downdelay != nil {
		return true
	}

	return false
}

// SetDowndelay gets a reference to the given int32 and assigns it to the Downdelay field.
func (o *LinkLinkinfoInfoData) SetDowndelay(v int32) {
	o.Downdelay = &v
}

func (o LinkLinkinfoInfoData) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.Mode != nil {
		toSerialize["mode"] = o.Mode
	}
	if o.Miimon != nil {
		toSerialize["miimon"] = o.Miimon
	}
	if o.Updelay != nil {
		toSerialize["updelay"] = o.Updelay
	}
	if o.Downdelay != nil {
		toSerialize["downdelay"] = o.Downdelay
	}
	return json.Marshal(toSerialize)
}

type NullableLinkLinkinfoInfoData struct {
	value *LinkLinkinfoInfoData
	isSet bool
}

func (v NullableLinkLinkinfoInfoData) Get() *LinkLinkinfoInfoData {
	return v.value
}

func (v *NullableLinkLinkinfoInfoData) Set(val *LinkLinkinfoInfoData) {
	v.value = val
	v.isSet = true
}

func (v NullableLinkLinkinfoInfoData) IsSet() bool {
	return v.isSet
}

func (v *NullableLinkLinkinfoInfoData) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableLinkLinkinfoInfoData(val *LinkLinkinfoInfoData) *NullableLinkLinkinfoInfoData {
	return &NullableLinkLinkinfoInfoData{value: val, isSet: true}
}

func (v NullableLinkLinkinfoInfoData) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableLinkLinkinfoInfoData) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


